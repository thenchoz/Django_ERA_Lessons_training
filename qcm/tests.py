"""
Django tests for qcm app.

Generated by 'manage.py startapp' using Django 3.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/topics/testing/
"""

from random import randrange

from django.test import TestCase

from .models import Branch, Choice, Question, QuestionsSubset, Training


def create_branch(branch_name):
    """usage fct
    create a branch with branch_name as name
    """
    return Branch.objects.create(name=branch_name)


def create_questions_subset(questions_subset_name, branch_id=None):
    """usage fct
    create a questions subset with questions_subset_name as name
    using the branch corresponding to branch_id
    empty basic branch if branch_id is None
    """
    if branch_id is None:
        branch = create_branch(branch_name="empty name")
    else:
        branch = Branch.objects.get(id=branch_id)
    return branch.questionssubset_set.create(name=questions_subset_name)


def create_question(question_text, questions_subset_id=None):
    """usage fct
    create a question with question_text as text
    using the questions_subset corresponding to questions_subset_id
    empty basic branch and questions_subset if questions_subset_id is None
    """
    if questions_subset_id is None:
        questions_subset = create_questions_subset(questions_subset_name="empty name")
    else:
        questions_subset = QuestionsSubset.objects.get(id=questions_subset_id)
    return questions_subset.question_set.create(question_text=question_text)


def create_choice(choice_text, is_true=False, question_id=None):
    """usage fct
    create a choice with choie_text as text and is_true as boolean
    using the question corresponding to question_id
    empty basic branch, questions_subset and question if quesion_id is None
    """
    if question_id is None:
        question = create_question(question_text="empty text")
    else:
        question = Question.objects.get(id=question_id)
    return question.choice_set.create(choice_text=choice_text, is_true=is_true)


def create_training(questions_subset_id=None):
    """usage fct
    create a training
    using the questions_subset corresponding to questions_subset_id
    empty basic branch and questions_subset if questions_subset_id is None
    """
    if questions_subset_id is None:
        questions_subset = create_questions_subset(questions_subset_name="empty name")
    else:
        questions_subset = QuestionsSubset.objects.get(id=questions_subset_id)
    return questions_subset.training_set.create()


class BranchModelTest(TestCase):
    """class to test the Branch model"""

    def test_create_branch(self):
        """test a branch creation"""
        name = "empty branch"
        branch = create_branch(branch_name=name)
        branchs = Branch.objects.all()
        self.assertQuerysetEqual(branchs, [branch])

    def test_get_questions_shuffled_is_complete_and_unique_with_one_subset(self):
        """test fct Branch::get_questions_shuffled
        test if all questions are in queryset
        test if queryset is the same size as all question
        test if not equal base list
        """
        branch = create_branch(branch_name="branch shuffled")
        questions_subset = create_questions_subset(
            questions_subset_name="questions shuffled", branch_id=branch.id
        )

        # create questions and get queryset
        nb_questions = randrange(1, 100)
        questions = []
        for i in range(nb_questions):
            question = questions_subset.question_set.create(
                question_text="random " + str(i)
            )
            questions.append(question)
        questions_shuffled = branch.get_questions_shuffled()

        # test for all question in queryset
        self.assertEqual(len(questions_shuffled), len(questions))
        for question in questions:
            self.assertTrue(question in questions_shuffled)
        self.assertNotEqual(questions, questions_shuffled)

    def test_get_questions_shuffled_is_complete_and_unique_with_n_subset(self):
        """test fct Branch::get_questions_shuffled
        test if all questions are in queryset
        test if queryset is the same size as all question
        test if not equal base list
        """
        branch = create_branch(branch_name="branch shuffled")
        nb_subsets = randrange(1, 10)

        # create subsets
        questions_subsets = []
        for i in range(nb_subsets):
            questions_subset = create_questions_subset(
                questions_subset_name="questions shuffled " + str(i),
                branch_id=branch.id,
            )
            questions_subsets.append(questions_subset)

        # create questions and get queryset
        nb_questions = randrange(1, 100)
        questions = []
        for i in range(nb_questions):
            jndice = randrange(nb_subsets)
            question = questions_subsets[jndice].question_set.create(
                question_text="random " + str(i)
            )
            questions.append(question)
        questions_shuffled = branch.get_questions_shuffled()

        # test for all question in queryset
        self.assertEqual(len(questions_shuffled), len(questions))
        for question in questions:
            self.assertTrue(question in questions_shuffled)
        self.assertNotEqual(questions, questions_shuffled)


class QuestionsSubsetModelTest(TestCase):
    """class to test the Questions subset model"""

    def test_create_questions_subset(self):
        """test a question subset creation"""
        name = "empty questions subset"
        questions_subset = create_questions_subset(questions_subset_name=name)
        questions_subsets = QuestionsSubset.objects.all()
        self.assertQuerysetEqual(questions_subsets, [questions_subset])

    def test_get_questions_shuffled_is_complete_and_unique(self):
        """test fct QuestionsSubset::get_questions_shuffled
        test if all questions are in queryset
        test if queryset is the same size as all question
        test if not equal base list
        """
        questions_subset = create_questions_subset(
            questions_subset_name="questions shuffled"
        )

        # create questions and get queryset
        nb_questions = randrange(1, 100)
        questions = []
        for i in range(nb_questions):
            question = questions_subset.question_set.create(
                question_text="random " + str(i)
            )
            questions.append(question)
        questions_shuffled = questions_subset.get_questions_shuffled()

        # test for all question in queryset
        self.assertEqual(len(questions_shuffled), len(questions))
        for question in questions:
            self.assertTrue(question in questions_shuffled)
        self.assertNotEqual(questions, questions_shuffled)


class QuestionModelTest(TestCase):
    """class to test the Question model"""

    def test_create_question(self):
        """test a question creation"""
        question_text = "empty question"
        question = create_question(question_text)
        questions = Question.objects.all()
        self.assertQuerysetEqual(questions, [question])


class ChoiceModelTest(TestCase):
    """class to test the Choice model"""

    def test_create_choice(self):
        """test a choice creation"""
        choice_text = "empty choice"
        choice = create_choice(choice_text=choice_text, is_true=True)
        choices = Choice.objects.all()
        self.assertQuerysetEqual(choices, [choice])


class TrainingModelTest(TestCase):
    """class to test the Training model"""

    def test_create_training(self):
        """test a training creation"""
        training = create_training()
        trainings = Training.objects.all()
        self.assertQuerysetEqual(trainings, [training])
